{
  "kind": "ClusterManagementAddOn",
  "apiVersion": "addon.open-cluster-management.io/v1alpha1",
  "metadata": {
    "group": "addon.open-cluster-management.io",
    "version": "v1alpha1",
    "plural": "clustermanagementaddons",
    "singular": "clustermanagementaddon",
    "scope": "Cluster"
  },
  "spec": {
    "description": "spec represents a desired configuration for the agent on the cluster management add-on.",
    "fields": {
      "addOnConfiguration": {
        "type": "object",
        "description": "Deprecated: Use supportedConfigs filed instead\naddOnConfiguration is a reference to configuration information for the add-on.\nIn scenario where a multiple add-ons share the same add-on CRD, multiple ClusterManagementAddOn\nresources need to be created and reference the same AddOnConfiguration.",
        "fields": {
          "crName": {
            "type": "string",
            "description": "crName is the name of the CR used to configure instances of the managed add-on.\nThis field should be configured if add-on CR have a consistent name across the all of the ManagedCluster instaces."
          },
          "crdName": {
            "type": "string",
            "description": "crdName is the name of the CRD used to configure instances of the managed add-on.\nThis field should be configured if the add-on have a CRD that controls the configuration of the add-on."
          },
          "lastObservedGeneration": {
            "type": "integer",
            "description": "lastObservedGeneration is the observed generation of the custom resource for the configuration of the addon."
          }
        }
      },
      "addOnMeta": {
        "type": "object",
        "description": "addOnMeta is a reference to the metadata information for the add-on.",
        "fields": {
          "description": {
            "type": "string",
            "description": "description represents the detailed description of the add-on."
          },
          "displayName": {
            "type": "string",
            "description": "displayName represents the name of add-on that will be displayed."
          }
        }
      },
      "installStrategy": {
        "type": "object",
        "description": "InstallStrategy represents that related ManagedClusterAddOns should be installed\non certain clusters.",
        "default": {
          "type": "Manual"
        },
        "fields": {
          "placements": {
            "type": "array",
            "description": "Placements is a list of placement references honored when install strategy type is\nPlacements. All clusters selected by these placements will install the addon\nIf one cluster belongs to multiple placements, it will only apply the strategy defined\nlater in the order. That is to say, The latter strategy overrides the previous one.",
            "fields": {
              "configs": {
                "type": "array",
                "description": "Configs is the configuration of managedClusterAddon during installation.\nUser can override the configuration by updating the managedClusterAddon directly.",
                "fields": {
                  "group": {
                    "type": "string",
                    "description": "group of the add-on configuration.",
                    "default": ""
                  },
                  "name": {
                    "type": "string",
                    "description": "name of the add-on configuration.",
                    "required": true
                  },
                  "namespace": {
                    "type": "string",
                    "description": "namespace of the add-on configuration.\nIf this field is not set, the configuration is in the cluster scope."
                  },
                  "resource": {
                    "type": "string",
                    "description": "resource of the add-on configuration.",
                    "required": true
                  }
                }
              },
              "name": {
                "type": "string",
                "description": "Name is the name of the placement",
                "required": true
              },
              "namespace": {
                "type": "string",
                "description": "Namespace is the namespace of the placement",
                "required": true
              },
              "rolloutStrategy": {
                "type": "object",
                "description": "The rollout strategy to apply addon configurations change.\nThe rollout strategy only watches the addon configurations defined in ClusterManagementAddOn.",
                "default": {
                  "type": "All"
                },
                "fields": {
                  "all": {
                    "type": "object",
                    "description": "All defines required fields for RolloutStrategy type All",
                    "fields": {
                      "maxFailures": {
                        "type": "N/A",
                        "description": "MaxFailures is a percentage or number of clusters in the current rollout that can fail before\nproceeding to the next rollout. Fail means the cluster has a failed status or timeout status\n(does not reach successful status after ProgressDeadline).\nOnce the MaxFailures is breached, the rollout will stop.\nMaxFailures is only considered for rollout types Progressive and ProgressivePerGroup. For\nProgressive, this is considered over the total number of clusters. For ProgressivePerGroup,\nthis is considered according to the size of the current group. For both Progressive and\nProgressivePerGroup, the MaxFailures does not apply for MandatoryDecisionGroups, which tolerate\nno failures.\nDefault is that no failures are tolerated.",
                        "default": 0,
                        "validations": {
                          "pattern": "^((100|[0-9]{1,2})%|[0-9]+)$"
                        }
                      },
                      "minSuccessTime": {
                        "type": "string",
                        "description": "MinSuccessTime is a \"soak\" time. In other words, the minimum amount of time the workload\napplier controller will wait from the start of each rollout before proceeding (assuming a\nsuccessful state has been reached and MaxFailures wasn't breached).\nMinSuccessTime is only considered for rollout types Progressive and ProgressivePerGroup.\nThe default value is 0 meaning the workload applier proceeds immediately after a successful\nstate is reached.\nMinSuccessTime must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
                        "default": "0"
                      },
                      "progressDeadline": {
                        "type": "string",
                        "description": "ProgressDeadline defines how long workload applier controller will wait for the workload to\nreach a successful state in the cluster.\nIf the workload does not reach a successful state after ProgressDeadline, will stop waiting\nand workload will be treated as \"timeout\" and be counted into MaxFailures. Once the MaxFailures\nis breached, the rollout will stop.\nProgressDeadline default value is \"None\", meaning the workload applier will wait for a\nsuccessful state indefinitely.\nProgressDeadline must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
                        "default": "None",
                        "validations": {
                          "pattern": "^(([0-9])+[h|m|s])|None$"
                        }
                      }
                    }
                  },
                  "progressive": {
                    "type": "object",
                    "description": "Progressive defines required fields for RolloutStrategy type Progressive",
                    "fields": {
                      "mandatoryDecisionGroups": {
                        "type": "array",
                        "description": "List of the decision groups names or indexes to apply the workload first and fail if workload\ndid not reach successful state.\nGroupName or GroupIndex must match with the decisionGroups defined in the placement's\ndecisionStrategy",
                        "fields": {
                          "groupIndex": {
                            "type": "integer",
                            "description": "GroupIndex of the decision group should match the placementDecisions label value with label key\ncluster.open-cluster-management.io/decision-group-index"
                          },
                          "groupName": {
                            "type": "string",
                            "description": "GroupName of the decision group should match the placementDecisions label value with label key\ncluster.open-cluster-management.io/decision-group-name"
                          }
                        }
                      },
                      "maxConcurrency": {
                        "type": "N/A",
                        "description": "MaxConcurrency is the max number of clusters to deploy workload concurrently. The default value\nfor MaxConcurrency is determined from the clustersPerDecisionGroup defined in the\nplacement->DecisionStrategy.",
                        "validations": {
                          "pattern": "^((100|[0-9]{1,2})%|[0-9]+)$"
                        }
                      },
                      "maxFailures": {
                        "type": "N/A",
                        "description": "MaxFailures is a percentage or number of clusters in the current rollout that can fail before\nproceeding to the next rollout. Fail means the cluster has a failed status or timeout status\n(does not reach successful status after ProgressDeadline).\nOnce the MaxFailures is breached, the rollout will stop.\nMaxFailures is only considered for rollout types Progressive and ProgressivePerGroup. For\nProgressive, this is considered over the total number of clusters. For ProgressivePerGroup,\nthis is considered according to the size of the current group. For both Progressive and\nProgressivePerGroup, the MaxFailures does not apply for MandatoryDecisionGroups, which tolerate\nno failures.\nDefault is that no failures are tolerated.",
                        "default": 0,
                        "validations": {
                          "pattern": "^((100|[0-9]{1,2})%|[0-9]+)$"
                        }
                      },
                      "minSuccessTime": {
                        "type": "string",
                        "description": "MinSuccessTime is a \"soak\" time. In other words, the minimum amount of time the workload\napplier controller will wait from the start of each rollout before proceeding (assuming a\nsuccessful state has been reached and MaxFailures wasn't breached).\nMinSuccessTime is only considered for rollout types Progressive and ProgressivePerGroup.\nThe default value is 0 meaning the workload applier proceeds immediately after a successful\nstate is reached.\nMinSuccessTime must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
                        "default": "0"
                      },
                      "progressDeadline": {
                        "type": "string",
                        "description": "ProgressDeadline defines how long workload applier controller will wait for the workload to\nreach a successful state in the cluster.\nIf the workload does not reach a successful state after ProgressDeadline, will stop waiting\nand workload will be treated as \"timeout\" and be counted into MaxFailures. Once the MaxFailures\nis breached, the rollout will stop.\nProgressDeadline default value is \"None\", meaning the workload applier will wait for a\nsuccessful state indefinitely.\nProgressDeadline must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
                        "default": "None",
                        "validations": {
                          "pattern": "^(([0-9])+[h|m|s])|None$"
                        }
                      }
                    }
                  },
                  "progressivePerGroup": {
                    "type": "object",
                    "description": "ProgressivePerGroup defines required fields for RolloutStrategy type ProgressivePerGroup",
                    "fields": {
                      "mandatoryDecisionGroups": {
                        "type": "array",
                        "description": "List of the decision groups names or indexes to apply the workload first and fail if workload\ndid not reach successful state.\nGroupName or GroupIndex must match with the decisionGroups defined in the placement's\ndecisionStrategy",
                        "fields": {
                          "groupIndex": {
                            "type": "integer",
                            "description": "GroupIndex of the decision group should match the placementDecisions label value with label key\ncluster.open-cluster-management.io/decision-group-index"
                          },
                          "groupName": {
                            "type": "string",
                            "description": "GroupName of the decision group should match the placementDecisions label value with label key\ncluster.open-cluster-management.io/decision-group-name"
                          }
                        }
                      },
                      "maxFailures": {
                        "type": "N/A",
                        "description": "MaxFailures is a percentage or number of clusters in the current rollout that can fail before\nproceeding to the next rollout. Fail means the cluster has a failed status or timeout status\n(does not reach successful status after ProgressDeadline).\nOnce the MaxFailures is breached, the rollout will stop.\nMaxFailures is only considered for rollout types Progressive and ProgressivePerGroup. For\nProgressive, this is considered over the total number of clusters. For ProgressivePerGroup,\nthis is considered according to the size of the current group. For both Progressive and\nProgressivePerGroup, the MaxFailures does not apply for MandatoryDecisionGroups, which tolerate\nno failures.\nDefault is that no failures are tolerated.",
                        "default": 0,
                        "validations": {
                          "pattern": "^((100|[0-9]{1,2})%|[0-9]+)$"
                        }
                      },
                      "minSuccessTime": {
                        "type": "string",
                        "description": "MinSuccessTime is a \"soak\" time. In other words, the minimum amount of time the workload\napplier controller will wait from the start of each rollout before proceeding (assuming a\nsuccessful state has been reached and MaxFailures wasn't breached).\nMinSuccessTime is only considered for rollout types Progressive and ProgressivePerGroup.\nThe default value is 0 meaning the workload applier proceeds immediately after a successful\nstate is reached.\nMinSuccessTime must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
                        "default": "0"
                      },
                      "progressDeadline": {
                        "type": "string",
                        "description": "ProgressDeadline defines how long workload applier controller will wait for the workload to\nreach a successful state in the cluster.\nIf the workload does not reach a successful state after ProgressDeadline, will stop waiting\nand workload will be treated as \"timeout\" and be counted into MaxFailures. Once the MaxFailures\nis breached, the rollout will stop.\nProgressDeadline default value is \"None\", meaning the workload applier will wait for a\nsuccessful state indefinitely.\nProgressDeadline must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
                        "default": "None",
                        "validations": {
                          "pattern": "^(([0-9])+[h|m|s])|None$"
                        }
                      }
                    }
                  },
                  "type": {
                    "type": "string",
                    "description": "No description provided.",
                    "enum": [
                      "All",
                      "Progressive",
                      "ProgressivePerGroup"
                    ],
                    "default": "All"
                  }
                }
              }
            }
          },
          "type": {
            "type": "string",
            "description": "Type is the type of the install strategy, it can be:\n- Manual: no automatic install\n- Placements: install to clusters selected by placements.",
            "enum": [
              "Manual",
              "Placements"
            ],
            "default": "Manual"
          }
        }
      },
      "supportedConfigs": {
        "type": "array",
        "description": "supportedConfigs is a list of configuration types supported by add-on.\nAn empty list means the add-on does not require configurations.\nThe default is an empty list",
        "fields": {
          "defaultConfig": {
            "type": "object",
            "description": "defaultConfig represents the namespace and name of the default add-on configuration.\nIn scenario where all add-ons have a same configuration.",
            "fields": {
              "name": {
                "type": "string",
                "description": "name of the add-on configuration.",
                "required": true
              },
              "namespace": {
                "type": "string",
                "description": "namespace of the add-on configuration.\nIf this field is not set, the configuration is in the cluster scope."
              }
            }
          },
          "group": {
            "type": "string",
            "description": "group of the add-on configuration.",
            "default": ""
          },
          "resource": {
            "type": "string",
            "description": "resource of the add-on configuration.",
            "required": true
          }
        }
      }
    }
  },
  "status": {
    "description": "status represents the current status of cluster management add-on.",
    "fields": {
      "defaultconfigReferences": {
        "type": "array",
        "description": "defaultconfigReferences is a list of current add-on default configuration references.",
        "fields": {
          "desiredConfig": {
            "type": "object",
            "description": "desiredConfig record the desired config spec hash.",
            "fields": {
              "name": {
                "type": "string",
                "description": "name of the add-on configuration.",
                "required": true
              },
              "namespace": {
                "type": "string",
                "description": "namespace of the add-on configuration.\nIf this field is not set, the configuration is in the cluster scope."
              },
              "specHash": {
                "type": "string",
                "description": "spec hash for an add-on configuration."
              }
            }
          },
          "group": {
            "type": "string",
            "description": "group of the add-on configuration.",
            "default": ""
          },
          "resource": {
            "type": "string",
            "description": "resource of the add-on configuration.",
            "required": true
          }
        }
      },
      "installProgressions": {
        "type": "array",
        "description": "installProgression is a list of current add-on configuration references per placement.",
        "fields": {
          "conditions": {
            "type": "array",
            "description": "conditions describe the state of the managed and monitored components for the operator.",
            "fields": {
              "lastTransitionTime": {
                "type": "string",
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "required": true
              },
              "message": {
                "type": "string",
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "required": true
              },
              "observedGeneration": {
                "type": "integer",
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "validations": {
                  "minimum": 0
                }
              },
              "reason": {
                "type": "string",
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "required": true,
                "validations": {
                  "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                }
              },
              "status": {
                "type": "string",
                "description": "status of the condition, one of True, False, Unknown.",
                "required": true,
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "type": "string",
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                "required": true,
                "validations": {
                  "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                }
              }
            }
          },
          "configReferences": {
            "type": "array",
            "description": "configReferences is a list of current add-on configuration references.",
            "fields": {
              "desiredConfig": {
                "type": "object",
                "description": "desiredConfig record the desired config name and spec hash.",
                "fields": {
                  "name": {
                    "type": "string",
                    "description": "name of the add-on configuration.",
                    "required": true
                  },
                  "namespace": {
                    "type": "string",
                    "description": "namespace of the add-on configuration.\nIf this field is not set, the configuration is in the cluster scope."
                  },
                  "specHash": {
                    "type": "string",
                    "description": "spec hash for an add-on configuration."
                  }
                }
              },
              "group": {
                "type": "string",
                "description": "group of the add-on configuration.",
                "default": ""
              },
              "lastAppliedConfig": {
                "type": "object",
                "description": "lastAppliedConfig records the config spec hash when the all the corresponding\nManagedClusterAddOn are applied successfully.",
                "fields": {
                  "name": {
                    "type": "string",
                    "description": "name of the add-on configuration.",
                    "required": true
                  },
                  "namespace": {
                    "type": "string",
                    "description": "namespace of the add-on configuration.\nIf this field is not set, the configuration is in the cluster scope."
                  },
                  "specHash": {
                    "type": "string",
                    "description": "spec hash for an add-on configuration."
                  }
                }
              },
              "lastKnownGoodConfig": {
                "type": "object",
                "description": "lastKnownGoodConfig records the last known good config spec hash.\nFor fresh install or rollout with type UpdateAll or RollingUpdate, the\nlastKnownGoodConfig is the same as lastAppliedConfig.\nFor rollout with type RollingUpdateWithCanary, the lastKnownGoodConfig\nis the last successfully applied config spec hash of the canary placement.",
                "fields": {
                  "name": {
                    "type": "string",
                    "description": "name of the add-on configuration.",
                    "required": true
                  },
                  "namespace": {
                    "type": "string",
                    "description": "namespace of the add-on configuration.\nIf this field is not set, the configuration is in the cluster scope."
                  },
                  "specHash": {
                    "type": "string",
                    "description": "spec hash for an add-on configuration."
                  }
                }
              },
              "resource": {
                "type": "string",
                "description": "resource of the add-on configuration.",
                "required": true
              }
            }
          },
          "name": {
            "type": "string",
            "description": "Name is the name of the placement",
            "required": true
          },
          "namespace": {
            "type": "string",
            "description": "Namespace is the namespace of the placement",
            "required": true
          }
        }
      }
    }
  },
  "exampleYAML": "apiVersion: addon.open-cluster-management.io/v1alpha1\nkind: ClusterManagementAddOn\nmetadata:\n  name: example-clustermanagementaddon\nspec:\n  addOnConfiguration: {}\n  addOnMeta: {}\n  installStrategy: {'type': 'Manual'}\n  supportedConfigs: []\n"
}