{
  "kind": "ROSAControlPlane",
  "apiVersion": "controlplane.cluster.x-k8s.io/v1beta2",
  "metadata": {
    "group": "controlplane.cluster.x-k8s.io",
    "version": "v1beta2",
    "plural": "rosacontrolplanes",
    "singular": "rosacontrolplane",
    "scope": "Namespaced"
  },
  "spec": {
    "description": "RosaControlPlaneSpec defines the desired state of ROSAControlPlane.",
    "fields": {
      "additionalTags": {
        "type": "object",
        "description": "AdditionalTags are user-defined tags to be added on the AWS resources associated with the control plane."
      },
      "auditLogRoleARN": {
        "type": "string",
        "description": "AuditLogRoleARN defines the role that is used to forward audit logs to AWS CloudWatch.\nIf not set, audit log forwarding is disabled."
      },
      "autoNode": {
        "type": "object",
        "description": "autoNode set the autoNode mode and roleARN.",
        "fields": {
          "mode": {
            "type": "string",
            "description": "mode specifies the mode for the AutoNode. Setting Enable/Disable mode will allows/disallow karpenter AutoNode scaling.",
            "enum": [
              "Enabled",
              "Disabled"
            ],
            "default": "Disabled"
          },
          "roleARN": {
            "type": "string",
            "description": "roleARN sets the autoNode role ARN, which includes the IAM policy and cluster-specific role that grant the necessary permissions to the Karpenter controller.\nThe role must be attached with the same OIDC-ID that is used with the ROSA-HCP cluster."
          }
        }
      },
      "availabilityZones": {
        "type": "array",
        "description": "AvailabilityZones describe AWS AvailabilityZones of the worker nodes.\nshould match the AvailabilityZones of the provided Subnets.\na machinepool will be created for each availabilityZone."
      },
      "billingAccount": {
        "type": "string",
        "description": "BillingAccount is an optional AWS account to use for billing the subscription fees for ROSA HCP clusters.\nThe cost of running each ROSA HCP cluster will be billed to the infrastructure account in which the cluster\nis running."
      },
      "channelGroup": {
        "type": "string",
        "description": "OpenShift version channel group, default is stable.",
        "required": true,
        "enum": [
          "stable",
          "eus",
          "fast",
          "candidate",
          "nightly"
        ],
        "default": "stable"
      },
      "clusterRegistryConfig": {
        "type": "object",
        "description": "ClusterRegistryConfig represents registry config used with the cluster.",
        "fields": {
          "additionalTrustedCAs": {
            "type": "object",
            "description": "AdditionalTrustedCAs containing the registry hostname as the key, and the PEM-encoded certificate as the value,\nfor each additional registry CA to trust."
          },
          "allowedRegistriesForImport": {
            "type": "array",
            "description": "AllowedRegistriesForImport limits the container image registries that normal users may import\nimages from. Set this list to the registries that you trust to contain valid Docker\nimages and that you want applications to be able to import from.",
            "fields": {
              "domainName": {
                "type": "string",
                "description": "domainName specifies a domain name for the registry. The domain name might include wildcards, like '*' or '??'.\nIn case the registry use non-standard (80 or 443) port, the port should be included in the domain name as well."
              },
              "insecure": {
                "type": "boolean",
                "description": "insecure indicates whether the registry is secure (https) or insecure (http), default is secured.",
                "default": false
              }
            }
          },
          "registrySources": {
            "type": "object",
            "description": "RegistrySources contains configuration that determines how the container runtime\nshould treat individual registries when accessing images. It does not contain configuration\nfor the internal cluster registry. AllowedRegistries, BlockedRegistries are mutually exclusive.",
            "fields": {
              "allowedRegistries": {
                "type": "array",
                "description": "AllowedRegistries are the registries for which image pull and push actions are allowed.\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\nFor example, *.example.com.\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest.\nAll other registries are blocked."
              },
              "blockedRegistries": {
                "type": "array",
                "description": "BlockedRegistries are the registries for which image pull and push actions are denied.\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\nFor example, *.example.com.\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest.\nAll other registries are allowed."
              },
              "insecureRegistries": {
                "type": "array",
                "description": "InsecureRegistries are registries which do not have a valid TLS certificate or only support HTTP connections.\nTo specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name,\nFor example, *.example.com.\nYou can specify an individual repository within a registry, For example: reg1.io/myrepo/myapp:latest."
              }
            }
          }
        }
      },
      "controlPlaneEndpoint": {
        "type": "object",
        "description": "ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.",
        "fields": {
          "host": {
            "type": "string",
            "description": "host is the hostname on which the API server is serving.",
            "required": true
          },
          "port": {
            "type": "integer",
            "description": "port is the port on which the API server is serving.",
            "required": true
          }
        }
      },
      "credentialsSecretRef": {
        "type": "object",
        "description": "CredentialsSecretRef references a secret with necessary credentials to connect to the OCM API.\nThe secret should contain the following data keys:\n- ocmToken: eyJhbGciOiJIUzI1NiIsI....\n- ocmApiUrl: Optional, defaults to 'https://api.openshift.com'",
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "defaultMachinePoolSpec": {
        "type": "object",
        "description": "DefaultMachinePoolSpec defines the configuration for the default machinepool(s) provisioned as part of the cluster creation.\nOne MachinePool will be created with this configuration per AvailabilityZone. Those default machinepools are required for openshift cluster operators\nto work properly.\nAs these machinepool not created using ROSAMachinePool CR, they will not be visible/managed by ROSA CAPI provider.\n`rosa list machinepools -c <rosaClusterName>` can be used to view those machinepools.\nThis field will be removed in the future once the current limitation is resolved.",
        "fields": {
          "autoscaling": {
            "type": "object",
            "description": "Autoscaling specifies auto scaling behaviour for the default MachinePool. Autoscaling min/max value\nmust be equal or multiple of the availability zones count.",
            "fields": {
              "maxReplicas": {
                "type": "integer",
                "description": "No description provided.",
                "validations": {
                  "minimum": 1
                }
              },
              "minReplicas": {
                "type": "integer",
                "description": "No description provided.",
                "validations": {
                  "minimum": 1
                }
              }
            }
          },
          "instanceType": {
            "type": "string",
            "description": "The instance type to use, for example `r5.xlarge`. Instance type ref; https://aws.amazon.com/ec2/instance-types/"
          },
          "volumeSize": {
            "type": "integer",
            "description": "VolumeSize set the disk volume size for the default workers machine pool in Gib. The default is 300 GiB.",
            "validations": {
              "minimum": 75,
              "maximum": 16384
            }
          }
        }
      },
      "domainPrefix": {
        "type": "string",
        "description": "DomainPrefix is an optional prefix added to the cluster's domain name. It will be used\nwhen generating a sub-domain for the cluster on openshiftapps domain. It must be valid DNS-1035 label\nconsisting of lower case alphanumeric characters or '-', start with an alphabetic character\nend with an alphanumeric character and have a max length of 15 characters.",
        "validations": {
          "pattern": "^[a-z]([-a-z0-9]*[a-z0-9])?$"
        }
      },
      "enableExternalAuthProviders": {
        "type": "boolean",
        "description": "EnableExternalAuthProviders enables external authentication configuration for the cluster.",
        "default": false
      },
      "endpointAccess": {
        "type": "string",
        "description": "EndpointAccess specifies the publishing scope of cluster endpoints. The\ndefault is Public.",
        "enum": [
          "Public",
          "Private"
        ],
        "default": "Public"
      },
      "etcdEncryptionKMSARN": {
        "type": "string",
        "description": "EtcdEncryptionKMSARN is the ARN of the KMS key used to encrypt etcd. The key itself needs to be\ncreated out-of-band by the user and tagged with `red-hat:true`."
      },
      "externalAuthProviders": {
        "type": "array",
        "description": "ExternalAuthProviders are external OIDC identity providers that can issue tokens for this cluster.\nCan only be set if \"enableExternalAuthProviders\" is set to \"True\".\nAt most one provider can be configured.",
        "fields": {
          "claimMappings": {
            "type": "object",
            "description": "ClaimMappings describes rules on how to transform information from an\nID token into a cluster identity",
            "fields": {
              "groups": {
                "type": "object",
                "description": "Groups is a name of the claim that should be used to construct\ngroups for the cluster identity.\nThe referenced claim must use array of strings values.",
                "fields": {
                  "claim": {
                    "type": "string",
                    "description": "Claim is a JWT token claim to be used in the mapping",
                    "required": true
                  },
                  "prefix": {
                    "type": "string",
                    "description": "Prefix is a string to prefix the value from the token in the result of the\nclaim mapping.\nBy default, no prefixing occurs.\nExample: if `prefix` is set to \"myoidc:\"\" and the `claim` in JWT contains\nan array of strings \"a\", \"b\" and  \"c\", the mapping will result in an\narray of string \"myoidc:a\", \"myoidc:b\" and \"myoidc:c\"."
                  }
                }
              },
              "username": {
                "type": "object",
                "description": "Username is a name of the claim that should be used to construct\nusernames for the cluster identity.\nDefault value: \"sub\"",
                "fields": {
                  "claim": {
                    "type": "string",
                    "description": "Claim is a JWT token claim to be used in the mapping",
                    "required": true
                  },
                  "prefix": {
                    "type": "string",
                    "description": "Prefix is prepended to claim to prevent clashes with existing names."
                  },
                  "prefixPolicy": {
                    "type": "string",
                    "description": "PrefixPolicy specifies how a prefix should apply.\nBy default, claims other than `email` will be prefixed with the issuer URL to\nprevent naming clashes with other plugins.\nSet to \"NoPrefix\" to disable prefixing.\nExample:\n    (1) `prefix` is set to \"myoidc:\" and `claim` is set to \"username\".\n        If the JWT claim `username` contains value `userA`, the resulting\n        mapped value will be \"myoidc:userA\".\n    (2) `prefix` is set to \"myoidc:\" and `claim` is set to \"email\". If the\n        JWT `email` claim contains value \"userA@myoidc.tld\", the resulting\n        mapped value will be \"myoidc:userA@myoidc.tld\".\n    (3) `prefix` is unset, `issuerURL` is set to `https://myoidc.tld`,\n        the JWT claims include \"username\":\"userA\" and \"email\":\"userA@myoidc.tld\",\n        and `claim` is set to:\n        (a) \"username\": the mapped value will be \"https://myoidc.tld#userA\"\n        (b) \"email\": the mapped value will be \"userA@myoidc.tld\"",
                    "enum": [
                      "",
                      "NoPrefix",
                      "Prefix"
                    ]
                  }
                }
              }
            }
          },
          "claimValidationRules": {
            "type": "array",
            "description": "ClaimValidationRules are rules that are applied to validate token claims to authenticate users.",
            "fields": {
              "requiredClaim": {
                "type": "object",
                "description": "RequiredClaim allows configuring a required claim name and its expected value",
                "required": true,
                "fields": {
                  "claim": {
                    "type": "string",
                    "description": "Claim is a name of a required claim. Only claims with string values are\nsupported.",
                    "required": true
                  },
                  "requiredValue": {
                    "type": "string",
                    "description": "RequiredValue is the required value for the claim.",
                    "required": true
                  }
                }
              },
              "type": {
                "type": "string",
                "description": "Type sets the type of the validation rule",
                "required": true,
                "enum": [
                  "RequiredClaim"
                ],
                "default": "RequiredClaim"
              }
            }
          },
          "issuer": {
            "type": "object",
            "description": "Issuer describes attributes of the OIDC token issuer",
            "required": true,
            "fields": {
              "audiences": {
                "type": "array",
                "description": "Audiences is an array of audiences that the token was issued for.\nValid tokens must include at least one of these values in their\n\"aud\" claim.\nMust be set to exactly one value.",
                "required": true
              },
              "issuerCertificateAuthority": {
                "type": "object",
                "description": "CertificateAuthority is a reference to a config map in the\nconfiguration namespace. The .data of the configMap must contain\nthe \"ca-bundle.crt\" key.\nIf unset, system trust is used instead.",
                "fields": {
                  "name": {
                    "type": "string",
                    "description": "Name is the metadata.name of the referenced object.",
                    "required": true
                  }
                }
              },
              "issuerURL": {
                "type": "string",
                "description": "URL is the serving URL of the token issuer.\nMust use the https:// scheme.",
                "required": true,
                "validations": {
                  "pattern": "^https:\\/\\/[^\\s]"
                }
              }
            }
          },
          "name": {
            "type": "string",
            "description": "Name of the OIDC provider",
            "required": true
          },
          "oidcClients": {
            "type": "array",
            "description": "OIDCClients contains configuration for the platform's clients that\nneed to request tokens from the issuer",
            "fields": {
              "clientID": {
                "type": "string",
                "description": "ClientID is the identifier of the OIDC client from the OIDC provider",
                "required": true
              },
              "clientSecret": {
                "type": "object",
                "description": "ClientSecret refers to a secret that\ncontains the client secret in the `clientSecret` key of the `.data` field",
                "required": true,
                "fields": {
                  "name": {
                    "type": "string",
                    "description": "Name is the metadata.name of the referenced object.",
                    "required": true
                  }
                }
              },
              "componentName": {
                "type": "string",
                "description": "ComponentName is the name of the component that is supposed to consume this\nclient configuration",
                "required": true
              },
              "componentNamespace": {
                "type": "string",
                "description": "ComponentNamespace is the namespace of the component that is supposed to consume this\nclient configuration",
                "required": true
              },
              "extraScopes": {
                "type": "array",
                "description": "ExtraScopes is an optional set of scopes to request tokens with."
              }
            }
          }
        }
      },
      "identityRef": {
        "type": "object",
        "description": "IdentityRef is a reference to an identity to be used when reconciling the managed control plane.\nIf no identity is specified, the default identity for this controller will be used.",
        "fields": {
          "kind": {
            "type": "string",
            "description": "Kind of the identity.",
            "required": true,
            "enum": [
              "AWSClusterControllerIdentity",
              "AWSClusterRoleIdentity",
              "AWSClusterStaticIdentity"
            ]
          },
          "name": {
            "type": "string",
            "description": "Name of the identity.",
            "required": true
          }
        }
      },
      "installerRoleARN": {
        "type": "string",
        "description": "InstallerRoleARN is an AWS IAM role that OpenShift Cluster Manager will assume to create the cluster.\nRequired if RosaRoleConfigRef is not specified."
      },
      "network": {
        "type": "object",
        "description": "Network config for the ROSA HCP cluster.",
        "fields": {
          "hostPrefix": {
            "type": "integer",
            "description": "Network host prefix which is defaulted to `23` if not specified.",
            "default": 23
          },
          "machineCIDR": {
            "type": "string",
            "description": "IP addresses block used by OpenShift while installing the cluster, for example \"10.0.0.0/16\"."
          },
          "networkType": {
            "type": "string",
            "description": "The CNI network type default is OVNKubernetes.",
            "enum": [
              "OVNKubernetes",
              "Other"
            ],
            "default": "OVNKubernetes"
          },
          "podCIDR": {
            "type": "string",
            "description": "IP address block from which to assign pod IP addresses, for example `10.128.0.0/14`."
          },
          "serviceCIDR": {
            "type": "string",
            "description": "IP address block from which to assign service IP addresses, for example `172.30.0.0/16`."
          }
        }
      },
      "oidcID": {
        "type": "string",
        "description": "The ID of the internal OpenID Connect Provider.\nRequired if RosaRoleConfigRef is not specified."
      },
      "provisionShardID": {
        "type": "string",
        "description": "ProvisionShardID defines the shard where ROSA hosted control plane components will be hosted."
      },
      "region": {
        "type": "string",
        "description": "The AWS Region the cluster lives in.",
        "required": true
      },
      "rolesRef": {
        "type": "object",
        "description": "AWS IAM roles used to perform credential requests by the openshift operators.\nRequired if RosaRoleConfigRef is not specified.",
        "fields": {
          "controlPlaneOperatorARN": {
            "type": "string",
            "description": "ControlPlaneOperatorARN  is an ARN value referencing a role appropriate for the Control Plane Operator.\n\nThe following is an example of a valid policy document:\n\n{\n\t\"Version\": \"2012-10-17\",\n\t\"Statement\": [\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"ec2:CreateVpcEndpoint\",\n\t\t\t\t\"ec2:DescribeVpcEndpoints\",\n\t\t\t\t\"ec2:ModifyVpcEndpoint\",\n\t\t\t\t\"ec2:DeleteVpcEndpoints\",\n\t\t\t\t\"ec2:CreateTags\",\n\t\t\t\t\"route53:ListHostedZones\",\n\t\t\t\t\"ec2:CreateSecurityGroup\",\n\t\t\t\t\"ec2:AuthorizeSecurityGroupIngress\",\n\t\t\t\t\"ec2:AuthorizeSecurityGroupEgress\",\n\t\t\t\t\"ec2:DeleteSecurityGroup\",\n\t\t\t\t\"ec2:RevokeSecurityGroupIngress\",\n\t\t\t\t\"ec2:RevokeSecurityGroupEgress\",\n\t\t\t\t\"ec2:DescribeSecurityGroups\",\n\t\t\t\t\"ec2:DescribeVpcs\",\n\t\t\t],\n\t\t\t\"Resource\": \"*\"\n\t\t},\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"route53:ChangeResourceRecordSets\",\n\t\t\t\t\"route53:ListResourceRecordSets\"\n\t\t\t],\n\t\t\t\"Resource\": \"arn:aws:route53:::%s\"\n\t\t}\n\t]\n}",
            "required": true
          },
          "imageRegistryARN": {
            "type": "string",
            "description": "ImageRegistryARN is an ARN value referencing a role appropriate for the Image Registry Operator.\n\nThe following is an example of a valid policy document:\n\n{\n\t\"Version\": \"2012-10-17\",\n\t\"Statement\": [\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"s3:CreateBucket\",\n\t\t\t\t\"s3:DeleteBucket\",\n\t\t\t\t\"s3:PutBucketTagging\",\n\t\t\t\t\"s3:GetBucketTagging\",\n\t\t\t\t\"s3:PutBucketPublicAccessBlock\",\n\t\t\t\t\"s3:GetBucketPublicAccessBlock\",\n\t\t\t\t\"s3:PutEncryptionConfiguration\",\n\t\t\t\t\"s3:GetEncryptionConfiguration\",\n\t\t\t\t\"s3:PutLifecycleConfiguration\",\n\t\t\t\t\"s3:GetLifecycleConfiguration\",\n\t\t\t\t\"s3:GetBucketLocation\",\n\t\t\t\t\"s3:ListBucket\",\n\t\t\t\t\"s3:GetObject\",\n\t\t\t\t\"s3:PutObject\",\n\t\t\t\t\"s3:DeleteObject\",\n\t\t\t\t\"s3:ListBucketMultipartUploads\",\n\t\t\t\t\"s3:AbortMultipartUpload\",\n\t\t\t\t\"s3:ListMultipartUploadParts\"\n\t\t\t],\n\t\t\t\"Resource\": \"*\"\n\t\t}\n\t]\n}",
            "required": true
          },
          "ingressARN": {
            "type": "string",
            "description": "The referenced role must have a trust relationship that allows it to be assumed via web identity.\nhttps://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc.html.\nExample:\n{\n\t\t\"Version\": \"2012-10-17\",\n\t\t\"Statement\": [\n\t\t\t{\n\t\t\t\t\"Effect\": \"Allow\",\n\t\t\t\t\"Principal\": {\n\t\t\t\t\t\"Federated\": \"\"\n\t\t\t\t},\n\t\t\t\t\t\"Action\": \"sts:AssumeRoleWithWebIdentity\",\n\t\t\t\t\"Condition\": {\n\t\t\t\t\t\"StringEquals\": {\n\t\t\t\t\t\t\":sub\": \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n\nIngressARN is an ARN value referencing a role appropriate for the Ingress Operator.\n\nThe following is an example of a valid policy document:\n\n{\n\t\"Version\": \"2012-10-17\",\n\t\"Statement\": [\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"elasticloadbalancing:DescribeLoadBalancers\",\n\t\t\t\t\"tag:GetResources\",\n\t\t\t\t\"route53:ListHostedZones\"\n\t\t\t],\n\t\t\t\"Resource\": \"*\"\n\t\t},\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"route53:ChangeResourceRecordSets\"\n\t\t\t],\n\t\t\t\"Resource\": [\n\t\t\t\t\"arn:aws:route53:::PUBLIC_ZONE_ID\",\n\t\t\t\t\"arn:aws:route53:::PRIVATE_ZONE_ID\"\n\t\t\t]\n\t\t}\n\t]\n}",
            "required": true
          },
          "kmsProviderARN": {
            "type": "string",
            "description": "No description provided.",
            "required": true
          },
          "kubeCloudControllerARN": {
            "type": "string",
            "description": "KubeCloudControllerARN is an ARN value referencing a role appropriate for the KCM/KCC.\nSource: https://cloud-provider-aws.sigs.k8s.io/prerequisites/#iam-policies\nThe following is an example of a valid policy document:\n {\n \"Version\": \"2012-10-17\",\n \"Statement\": [\n   {\n     \"Action\": [\n       \"autoscaling:DescribeAutoScalingGroups\",\n       \"autoscaling:DescribeLaunchConfigurations\",\n       \"autoscaling:DescribeTags\",\n       \"ec2:DescribeAvailabilityZones\",\n       \"ec2:DescribeInstances\",\n       \"ec2:DescribeImages\",\n       \"ec2:DescribeRegions\",\n       \"ec2:DescribeRouteTables\",\n       \"ec2:DescribeSecurityGroups\",\n       \"ec2:DescribeSubnets\",\n       \"ec2:DescribeVolumes\",\n       \"ec2:CreateSecurityGroup\",\n       \"ec2:CreateTags\",\n       \"ec2:CreateVolume\",\n       \"ec2:ModifyInstanceAttribute\",\n       \"ec2:ModifyVolume\",\n       \"ec2:AttachVolume\",\n       \"ec2:AuthorizeSecurityGroupIngress\",\n       \"ec2:CreateRoute\",\n       \"ec2:DeleteRoute\",\n       \"ec2:DeleteSecurityGroup\",\n       \"ec2:DeleteVolume\",\n       \"ec2:DetachVolume\",\n       \"ec2:RevokeSecurityGroupIngress\",\n       \"ec2:DescribeVpcs\",\n       \"elasticloadbalancing:AddTags\",\n       \"elasticloadbalancing:AttachLoadBalancerToSubnets\",\n       \"elasticloadbalancing:ApplySecurityGroupsToLoadBalancer\",\n       \"elasticloadbalancing:CreateLoadBalancer\",\n       \"elasticloadbalancing:CreateLoadBalancerPolicy\",\n       \"elasticloadbalancing:CreateLoadBalancerListeners\",\n       \"elasticloadbalancing:ConfigureHealthCheck\",\n       \"elasticloadbalancing:DeleteLoadBalancer\",\n       \"elasticloadbalancing:DeleteLoadBalancerListeners\",\n       \"elasticloadbalancing:DescribeLoadBalancers\",\n       \"elasticloadbalancing:DescribeLoadBalancerAttributes\",\n       \"elasticloadbalancing:DetachLoadBalancerFromSubnets\",\n       \"elasticloadbalancing:DeregisterInstancesFromLoadBalancer\",\n       \"elasticloadbalancing:ModifyLoadBalancerAttributes\",\n       \"elasticloadbalancing:RegisterInstancesWithLoadBalancer\",\n       \"elasticloadbalancing:SetLoadBalancerPoliciesForBackendServer\",\n       \"elasticloadbalancing:AddTags\",\n       \"elasticloadbalancing:CreateListener\",\n       \"elasticloadbalancing:CreateTargetGroup\",\n       \"elasticloadbalancing:DeleteListener\",\n       \"elasticloadbalancing:DeleteTargetGroup\",\n       \"elasticloadbalancing:DeregisterTargets\",\n       \"elasticloadbalancing:DescribeListeners\",\n       \"elasticloadbalancing:DescribeLoadBalancerPolicies\",\n       \"elasticloadbalancing:DescribeTargetGroups\",\n       \"elasticloadbalancing:DescribeTargetHealth\",\n       \"elasticloadbalancing:ModifyListener\",\n       \"elasticloadbalancing:ModifyTargetGroup\",\n       \"elasticloadbalancing:RegisterTargets\",\n       \"elasticloadbalancing:SetLoadBalancerPoliciesOfListener\",\n       \"iam:CreateServiceLinkedRole\",\n       \"kms:DescribeKey\"\n     ],\n     \"Resource\": [\n       \"*\"\n     ],\n     \"Effect\": \"Allow\"\n   }\n ]\n}",
            "required": true
          },
          "networkARN": {
            "type": "string",
            "description": "NetworkARN is an ARN value referencing a role appropriate for the Network Operator.\n\nThe following is an example of a valid policy document:\n\n{\n\t\"Version\": \"2012-10-17\",\n\t\"Statement\": [\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"ec2:DescribeInstances\",\n       \"ec2:DescribeInstanceStatus\",\n       \"ec2:DescribeInstanceTypes\",\n       \"ec2:UnassignPrivateIpAddresses\",\n       \"ec2:AssignPrivateIpAddresses\",\n       \"ec2:UnassignIpv6Addresses\",\n       \"ec2:AssignIpv6Addresses\",\n       \"ec2:DescribeSubnets\",\n       \"ec2:DescribeNetworkInterfaces\"\n\t\t\t],\n\t\t\t\"Resource\": \"*\"\n\t\t}\n\t]\n}",
            "required": true
          },
          "nodePoolManagementARN": {
            "type": "string",
            "description": "NodePoolManagementARN is an ARN value referencing a role appropriate for the CAPI Controller.\n\nThe following is an example of a valid policy document:\n\n{\n  \"Version\": \"2012-10-17\",\n \"Statement\": [\n   {\n     \"Action\": [\n       \"ec2:AssociateRouteTable\",\n       \"ec2:AttachInternetGateway\",\n       \"ec2:AuthorizeSecurityGroupIngress\",\n       \"ec2:CreateInternetGateway\",\n       \"ec2:CreateNatGateway\",\n       \"ec2:CreateRoute\",\n       \"ec2:CreateRouteTable\",\n       \"ec2:CreateSecurityGroup\",\n       \"ec2:CreateSubnet\",\n       \"ec2:CreateTags\",\n       \"ec2:DeleteInternetGateway\",\n       \"ec2:DeleteNatGateway\",\n       \"ec2:DeleteRouteTable\",\n       \"ec2:DeleteSecurityGroup\",\n       \"ec2:DeleteSubnet\",\n       \"ec2:DeleteTags\",\n       \"ec2:DescribeAccountAttributes\",\n       \"ec2:DescribeAddresses\",\n       \"ec2:DescribeAvailabilityZones\",\n       \"ec2:DescribeImages\",\n       \"ec2:DescribeInstances\",\n       \"ec2:DescribeInternetGateways\",\n       \"ec2:DescribeNatGateways\",\n       \"ec2:DescribeNetworkInterfaces\",\n       \"ec2:DescribeNetworkInterfaceAttribute\",\n       \"ec2:DescribeRouteTables\",\n       \"ec2:DescribeSecurityGroups\",\n       \"ec2:DescribeSubnets\",\n       \"ec2:DescribeVpcs\",\n       \"ec2:DescribeVpcAttribute\",\n       \"ec2:DescribeVolumes\",\n       \"ec2:DetachInternetGateway\",\n       \"ec2:DisassociateRouteTable\",\n       \"ec2:DisassociateAddress\",\n       \"ec2:ModifyInstanceAttribute\",\n       \"ec2:ModifyNetworkInterfaceAttribute\",\n       \"ec2:ModifySubnetAttribute\",\n       \"ec2:RevokeSecurityGroupIngress\",\n       \"ec2:RunInstances\",\n       \"ec2:TerminateInstances\",\n       \"tag:GetResources\",\n       \"ec2:CreateLaunchTemplate\",\n       \"ec2:CreateLaunchTemplateVersion\",\n       \"ec2:DescribeLaunchTemplates\",\n       \"ec2:DescribeLaunchTemplateVersions\",\n       \"ec2:DeleteLaunchTemplate\",\n       \"ec2:DeleteLaunchTemplateVersions\"\n     ],\n     \"Resource\": [\n       \"*\"\n     ],\n     \"Effect\": \"Allow\"\n   },\n   {\n     \"Condition\": {\n       \"StringLike\": {\n         \"iam:AWSServiceName\": \"elasticloadbalancing.amazonaws.com\"\n       }\n     },\n     \"Action\": [\n       \"iam:CreateServiceLinkedRole\"\n     ],\n     \"Resource\": [\n       \"arn:*:iam::*:role/aws-service-role/elasticloadbalancing.amazonaws.com/AWSServiceRoleForElasticLoadBalancing\"\n     ],\n     \"Effect\": \"Allow\"\n   },\n   {\n     \"Action\": [\n       \"iam:PassRole\"\n     ],\n     \"Resource\": [\n       \"arn:*:iam::*:role/*-worker-role\"\n     ],\n     \"Effect\": \"Allow\"\n   },\n\t  {\n\t  \t\"Effect\": \"Allow\",\n\t  \t\"Action\": [\n\t  \t\t\"kms:Decrypt\",\n\t  \t\t\"kms:ReEncrypt\",\n\t  \t\t\"kms:GenerateDataKeyWithoutPlainText\",\n\t  \t\t\"kms:DescribeKey\"\n\t  \t],\n\t  \t\"Resource\": \"*\"\n\t  },\n\t  {\n\t  \t\"Effect\": \"Allow\",\n\t  \t\"Action\": [\n\t  \t\t\"kms:CreateGrant\"\n\t  \t],\n\t  \t\"Resource\": \"*\",\n\t  \t\"Condition\": {\n\t  \t\t\"Bool\": {\n\t  \t\t\t\"kms:GrantIsForAWSResource\": true\n\t  \t\t}\n\t  \t}\n\t  }\n ]\n}",
            "required": true
          },
          "storageARN": {
            "type": "string",
            "description": "StorageARN is an ARN value referencing a role appropriate for the Storage Operator.\n\nThe following is an example of a valid policy document:\n\n{\n\t\"Version\": \"2012-10-17\",\n\t\"Statement\": [\n\t\t{\n\t\t\t\"Effect\": \"Allow\",\n\t\t\t\"Action\": [\n\t\t\t\t\"ec2:AttachVolume\",\n\t\t\t\t\"ec2:CreateSnapshot\",\n\t\t\t\t\"ec2:CreateTags\",\n\t\t\t\t\"ec2:CreateVolume\",\n\t\t\t\t\"ec2:DeleteSnapshot\",\n\t\t\t\t\"ec2:DeleteTags\",\n\t\t\t\t\"ec2:DeleteVolume\",\n\t\t\t\t\"ec2:DescribeInstances\",\n\t\t\t\t\"ec2:DescribeSnapshots\",\n\t\t\t\t\"ec2:DescribeTags\",\n\t\t\t\t\"ec2:DescribeVolumes\",\n\t\t\t\t\"ec2:DescribeVolumesModifications\",\n\t\t\t\t\"ec2:DetachVolume\",\n\t\t\t\t\"ec2:ModifyVolume\"\n\t\t\t],\n\t\t\t\"Resource\": \"*\"\n\t\t}\n\t]\n}",
            "required": true
          }
        }
      },
      "rosaClusterName": {
        "type": "string",
        "description": "Cluster name must be valid DNS-1035 label, so it must consist of lower case alphanumeric\ncharacters or '-', start with an alphabetic character, end with an alphanumeric character\nand have a max length of 54 characters.",
        "required": true,
        "validations": {
          "pattern": "^[a-z]([-a-z0-9]*[a-z0-9])?$"
        }
      },
      "rosaNetworkRef": {
        "type": "object",
        "description": "ROSANetworkRef references ROSANetwork custom resource that contains the networking infrastructure\nfor the ROSA HCP cluster.",
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "rosaRoleConfigRef": {
        "type": "object",
        "description": "RosaRoleConfigRef is a reference to a RosaRoleConfig resource that contains account roles, operator roles and OIDC configuration.\nRosaRoleConfigRef and role fields such as installerRoleARN, supportRoleARN, workerRoleARN, rolesRef and oidcID are mutually exclusive.",
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "subnets": {
        "type": "array",
        "description": "The Subnet IDs to use when installing the cluster.\nSubnetIDs should come in pairs; two per availability zone, one private and one public."
      },
      "supportRoleARN": {
        "type": "string",
        "description": "SupportRoleARN is an AWS IAM role used by Red Hat SREs to enable\naccess to the cluster account in order to provide support.\nRequired if RosaRoleConfigRef is not specified."
      },
      "version": {
        "type": "string",
        "description": "OpenShift semantic version, for example \"4.14.5\".",
        "required": true
      },
      "versionGate": {
        "type": "string",
        "description": "VersionGate requires acknowledgment when upgrading ROSA-HCP y-stream versions (e.g., from 4.15 to 4.16).\nDefault is WaitForAcknowledge.\nWaitForAcknowledge: If acknowledgment is required, the upgrade will not proceed until VersionGate is set to Acknowledge or AlwaysAcknowledge.\nAcknowledge: If acknowledgment is required, apply it for the upgrade. After upgrade is done set the version gate to WaitForAcknowledge.\nAlwaysAcknowledge: If acknowledgment is required, apply it and proceed with the upgrade.",
        "required": true,
        "enum": [
          "Acknowledge",
          "WaitForAcknowledge",
          "AlwaysAcknowledge"
        ],
        "default": "WaitForAcknowledge"
      },
      "workerRoleARN": {
        "type": "string",
        "description": "WorkerRoleARN is an AWS IAM role that will be attached to worker instances.\nRequired if RosaRoleConfigRef is not specified."
      }
    }
  },
  "status": {
    "description": "RosaControlPlaneStatus defines the observed state of ROSAControlPlane.",
    "fields": {
      "availableUpgrades": {
        "type": "array",
        "description": "Available upgrades for the ROSA hosted control plane."
      },
      "conditions": {
        "type": "array",
        "description": "Conditions specifies the conditions for the managed control plane",
        "fields": {
          "lastTransitionTime": {
            "type": "string",
            "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
            "required": true
          },
          "message": {
            "type": "string",
            "description": "message is a human readable message indicating details about the transition.\nThis field may be empty."
          },
          "reason": {
            "type": "string",
            "description": "reason is the reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may be empty."
          },
          "severity": {
            "type": "string",
            "description": "severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False."
          },
          "status": {
            "type": "string",
            "description": "status of the condition, one of True, False, Unknown.",
            "required": true
          },
          "type": {
            "type": "string",
            "description": "type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
            "required": true
          }
        }
      },
      "consoleURL": {
        "type": "string",
        "description": "ConsoleURL is the url for the openshift console."
      },
      "externalManagedControlPlane": {
        "type": "boolean",
        "description": "ExternalManagedControlPlane indicates to cluster-api that the control plane\nis managed by an external service such as AKS, EKS, GKE, etc.",
        "default": true
      },
      "failureMessage": {
        "type": "string",
        "description": "FailureMessage will be set in the event that there is a terminal problem\nreconciling the state and will be set to a descriptive error message.\nThis field should not be set for transitive errors that a controller\nfaces that are expected to be fixed automatically over\ntime (like service outages), but instead indicate that something is\nfundamentally wrong with the spec or the configuration of\nthe controller, and that manual intervention is required."
      },
      "id": {
        "type": "string",
        "description": "ID is the cluster ID given by ROSA."
      },
      "initialized": {
        "type": "boolean",
        "description": "Initialized denotes whether or not the control plane has the\nuploaded kubernetes config-map."
      },
      "oidcEndpointURL": {
        "type": "string",
        "description": "OIDCEndpointURL is the endpoint url for the managed OIDC provider."
      },
      "ready": {
        "type": "boolean",
        "description": "Ready denotes that the ROSAControlPlane API Server is ready to receive requests.",
        "required": true,
        "default": false
      },
      "version": {
        "type": "string",
        "description": "OpenShift semantic version, for example \"4.14.5\"."
      }
    }
  },
  "exampleYAML": "apiVersion: controlplane.cluster.x-k8s.io/v1beta2\nkind: ROSAControlPlane\nmetadata:\n  name: example-rosacontrolplane\n  namespace: default\nspec:\n  channelGroup: stable\n  region: \"example-region\"\n  rosaClusterName: \"example-rosaClusterName\"\n  version: \"example-version\"\n  versionGate: WaitForAcknowledge\n"
}