{
  "kind": "Placement",
  "apiVersion": "cluster.open-cluster-management.io/v1beta1",
  "metadata": {
    "group": "cluster.open-cluster-management.io",
    "version": "v1beta1",
    "plural": "placements",
    "singular": "placement",
    "scope": "Namespaced"
  },
  "spec": {
    "description": "Spec defines the attributes of Placement.",
    "fields": {
      "clusterSets": {
        "type": "array",
        "description": "ClusterSets represent the ManagedClusterSets from which the ManagedClusters are selected.\nIf the slice is empty, ManagedClusters will be selected from the ManagedClusterSets bound to the placement\nnamespace, otherwise ManagedClusters will be selected from the intersection of this slice and the\nManagedClusterSets bound to the placement namespace."
      },
      "decisionStrategy": {
        "type": "object",
        "description": "DecisionStrategy divide the created placement decision to groups and define number of clusters per decision group.",
        "fields": {
          "groupStrategy": {
            "type": "object",
            "description": "GroupStrategy define strategies to divide selected clusters to decision groups.",
            "fields": {
              "clustersPerDecisionGroup": {
                "type": "N/A",
                "description": "ClustersPerDecisionGroup is a specific number or percentage of the total selected clusters.\nThe specific number will divide the placementDecisions to decisionGroups each group has max number of clusters\nequal to that specific number.\nThe percentage will divide the placementDecisions to decisionGroups each group has max number of clusters based\non the total num of selected clusters and percentage.\nex; for a total 100 clusters selected, ClustersPerDecisionGroup equal to 20% will divide the placement decision\nto 5 groups each group should have 20 clusters.\nDefault is having all clusters in a single group.\nThe predefined decisionGroups is expected to be a subset of the selected clusters and the number of items in each\ngroup SHOULD be less than ClustersPerDecisionGroup. Once the number of items exceeds the ClustersPerDecisionGroup,\nthe decisionGroups will also be be divided into multiple decisionGroups with same GroupName but different GroupIndex.",
                "default": "100%",
                "validations": {
                  "pattern": "^((100|[1-9][0-9]{0,1})%|[1-9][0-9]*)$"
                }
              },
              "decisionGroups": {
                "type": "array",
                "description": "DecisionGroups represents a list of predefined groups to put decision results.\nDecision groups will be constructed based on the DecisionGroups field at first. The clusters not included in the\nDecisionGroups will be divided to other decision groups afterwards. Each decision group should not have the number\nof clusters larger than the ClustersPerDecisionGroup.",
                "fields": {
                  "groupClusterSelector": {
                    "type": "object",
                    "description": "LabelSelector to select clusters subset by label.",
                    "required": true,
                    "fields": {
                      "claimSelector": {
                        "type": "object",
                        "description": "ClaimSelector represents a selector of ManagedClusters by clusterClaims in status",
                        "fields": {
                          "matchExpressions": {
                            "type": "array",
                            "description": "matchExpressions is a list of cluster claim selector requirements. The requirements are ANDed.",
                            "fields": {
                              "key": {
                                "type": "string",
                                "description": "key is the label key that the selector applies to.",
                                "required": true
                              },
                              "operator": {
                                "type": "string",
                                "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                "required": true
                              },
                              "values": {
                                "type": "array",
                                "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch."
                              }
                            }
                          }
                        }
                      },
                      "labelSelector": {
                        "type": "object",
                        "description": "LabelSelector represents a selector of ManagedClusters by label",
                        "fields": {
                          "matchExpressions": {
                            "type": "array",
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "fields": {
                              "key": {
                                "type": "string",
                                "description": "key is the label key that the selector applies to.",
                                "required": true
                              },
                              "operator": {
                                "type": "string",
                                "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                "required": true
                              },
                              "values": {
                                "type": "array",
                                "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch."
                              }
                            }
                          },
                          "matchLabels": {
                            "type": "object",
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed."
                          }
                        }
                      }
                    }
                  },
                  "groupName": {
                    "type": "string",
                    "description": "Group name to be added as label value to the created placement Decisions labels with label key cluster.open-cluster-management.io/decision-group-name",
                    "required": true,
                    "validations": {
                      "pattern": "^[a-zA-Z0-9][-A-Za-z0-9_.]{0,61}[a-zA-Z0-9]$"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "numberOfClusters": {
        "type": "integer",
        "description": "NumberOfClusters represents the desired number of ManagedClusters to be selected which meet the\nplacement requirements.\n1) If not specified, all ManagedClusters which meet the placement requirements (including ClusterSets,\n   and Predicates) will be selected;\n2) Otherwise if the nubmer of ManagedClusters meet the placement requirements is larger than\n   NumberOfClusters, a random subset with desired number of ManagedClusters will be selected;\n3) If the nubmer of ManagedClusters meet the placement requirements is equal to NumberOfClusters,\n   all of them will be selected;\n4) If the nubmer of ManagedClusters meet the placement requirements is less than NumberOfClusters,\n   all of them will be selected, and the status of condition `PlacementConditionSatisfied` will be\n   set to false;"
      },
      "predicates": {
        "type": "array",
        "description": "Predicates represent a slice of predicates to select ManagedClusters. The predicates are ORed.",
        "fields": {
          "requiredClusterSelector": {
            "type": "object",
            "description": "RequiredClusterSelector represents a selector of ManagedClusters by label and claim. If specified,\n1) Any ManagedCluster, which does not match the selector, should not be selected by this ClusterPredicate;\n2) If a selected ManagedCluster (of this ClusterPredicate) ceases to match the selector (e.g. due to\n   an update) of any ClusterPredicate, it will be eventually removed from the placement decisions;\n3) If a ManagedCluster (not selected previously) starts to match the selector, it will either\n   be selected or at least has a chance to be selected (when NumberOfClusters is specified);",
            "fields": {
              "celSelector": {
                "type": "object",
                "description": "CelSelector represents a selector of ManagedClusters by CEL expressions on ManagedCluster fields",
                "fields": {
                  "celExpressions": {
                    "type": "array",
                    "description": "No description provided."
                  }
                }
              },
              "claimSelector": {
                "type": "object",
                "description": "ClaimSelector represents a selector of ManagedClusters by clusterClaims in status",
                "fields": {
                  "matchExpressions": {
                    "type": "array",
                    "description": "matchExpressions is a list of cluster claim selector requirements. The requirements are ANDed.",
                    "fields": {
                      "key": {
                        "type": "string",
                        "description": "key is the label key that the selector applies to.",
                        "required": true
                      },
                      "operator": {
                        "type": "string",
                        "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                        "required": true
                      },
                      "values": {
                        "type": "array",
                        "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch."
                      }
                    }
                  }
                }
              },
              "labelSelector": {
                "type": "object",
                "description": "LabelSelector represents a selector of ManagedClusters by label",
                "fields": {
                  "matchExpressions": {
                    "type": "array",
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "fields": {
                      "key": {
                        "type": "string",
                        "description": "key is the label key that the selector applies to.",
                        "required": true
                      },
                      "operator": {
                        "type": "string",
                        "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                        "required": true
                      },
                      "values": {
                        "type": "array",
                        "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch."
                      }
                    }
                  },
                  "matchLabels": {
                    "type": "object",
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed."
                  }
                }
              }
            }
          }
        }
      },
      "prioritizerPolicy": {
        "type": "object",
        "description": "PrioritizerPolicy defines the policy of the prioritizers.\nIf this field is unset, then default prioritizer mode and configurations are used.\nReferring to PrioritizerPolicy to see more description about Mode and Configurations.",
        "fields": {
          "configurations": {
            "type": "array",
            "description": "No description provided.",
            "fields": {
              "scoreCoordinate": {
                "type": "object",
                "description": "ScoreCoordinate represents the configuration of the prioritizer and score source.",
                "required": true,
                "fields": {
                  "addOn": {
                    "type": "object",
                    "description": "When type is \"AddOn\", AddOn defines the resource name and score name.",
                    "fields": {
                      "resourceName": {
                        "type": "string",
                        "description": "ResourceName defines the resource name of the AddOnPlacementScore.\nThe placement prioritizer selects AddOnPlacementScore CR by this name.",
                        "required": true
                      },
                      "scoreName": {
                        "type": "string",
                        "description": "ScoreName defines the score name inside AddOnPlacementScore.\nAddOnPlacementScore contains a list of score name and score value, ScoreName specify the score to be used by\nthe prioritizer.",
                        "required": true
                      }
                    }
                  },
                  "builtIn": {
                    "type": "string",
                    "description": "BuiltIn defines the name of a BuiltIn prioritizer. Below are the valid BuiltIn prioritizer names.\n1) Balance: balance the decisions among the clusters.\n2) Steady: ensure the existing decision is stabilized.\n3) ResourceAllocatableCPU & ResourceAllocatableMemory: sort clusters based on the allocatable.\n4) Spread: spread the workload evenly to topologies."
                  },
                  "type": {
                    "type": "string",
                    "description": "Type defines the type of the prioritizer score.\nType is either \"BuiltIn\", \"AddOn\" or \"\", where \"\" is \"BuiltIn\" by default.\nWhen the type is \"BuiltIn\", need to specify a BuiltIn prioritizer name in BuiltIn.\nWhen the type is \"AddOn\", need to configure the score source in AddOn.",
                    "required": true,
                    "enum": [
                      "BuiltIn",
                      "AddOn"
                    ],
                    "default": "BuiltIn"
                  }
                }
              },
              "weight": {
                "type": "integer",
                "description": "Weight defines the weight of the prioritizer score. The value must be ranged in [-10,10].\nEach prioritizer will calculate an integer score of a cluster in the range of [-100, 100].\nThe final score of a cluster will be sum(weight * prioritizer_score).\nA higher weight indicates that the prioritizer weights more in the cluster selection,\nwhile 0 weight indicates that the prioritizer is disabled. A negative weight indicates\nwants to select the last ones.",
                "default": 1,
                "validations": {
                  "minimum": -10,
                  "maximum": 10
                }
              }
            }
          },
          "mode": {
            "type": "string",
            "description": "Mode is either Exact, Additive, \"\" where \"\" is Additive by default.\nIn Additive mode, any prioritizer not explicitly enumerated is enabled in its default Configurations,\nin which Steady and Balance prioritizers have the weight of 1 while other prioritizers have the weight of 0.\nAdditive doesn't require configuring all prioritizers. The default Configurations may change in the future,\nand additional prioritization will happen.\nIn Exact mode, any prioritizer not explicitly enumerated is weighted as zero.\nExact requires knowing the full set of prioritizers you want, but avoids behavior changes between releases.",
            "default": "Additive"
          }
        }
      },
      "spreadPolicy": {
        "type": "object",
        "description": "SpreadPolicy defines how placement decisions should be distributed among a\nset of ManagedClusters.",
        "fields": {
          "spreadConstraints": {
            "type": "array",
            "description": "SpreadConstraints defines how the placement decision should be distributed among a set of ManagedClusters.\nThe importance of the SpreadConstraintsTerms follows the natural order of their index in the slice.\nThe scheduler first consider SpreadConstraintsTerms with smaller index then those with larger index\nto distribute the placement decision.",
            "fields": {
              "maxSkew": {
                "type": "integer",
                "description": "MaxSkew represents the degree to which the workload may be unevenly distributed.\nSkew is the maximum difference between the number of selected ManagedClusters in a topology and the global minimum.\nThe global minimum is the minimum number of selected ManagedClusters for the topologies within the same TopologyKey.\nThe minimum possible value of MaxSkew is 1, and the default value is 1.",
                "default": 1,
                "validations": {
                  "minimum": 1
                }
              },
              "topologyKey": {
                "type": "string",
                "description": "TopologyKey is either a label key or a cluster claim name of ManagedClusters.",
                "required": true,
                "validations": {
                  "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$"
                }
              },
              "topologyKeyType": {
                "type": "string",
                "description": "TopologyKeyType indicates the type of TopologyKey. It could be Label or Claim.",
                "required": true,
                "enum": [
                  "Label",
                  "Claim"
                ]
              },
              "whenUnsatisfiable": {
                "type": "string",
                "description": "WhenUnsatisfiable represents the action of the scheduler when MaxSkew cannot be satisfied.\nIt could be DoNotSchedule or ScheduleAnyway. The default value is ScheduleAnyway.\nDoNotSchedule instructs the scheduler not to schedule more ManagedClusters when MaxSkew is not satisfied.\nScheduleAnyway instructs the scheduler to keep scheduling even if MaxSkew is not satisfied.",
                "enum": [
                  "DoNotSchedule",
                  "ScheduleAnyway"
                ],
                "default": "ScheduleAnyway"
              }
            }
          }
        }
      },
      "tolerations": {
        "type": "array",
        "description": "Tolerations are applied to placements, and allow (but do not require) the managed clusters with\ncertain taints to be selected by placements with matching tolerations.",
        "fields": {
          "effect": {
            "type": "string",
            "description": "Effect indicates the taint effect to match. Empty means match all taint effects.\nWhen specified, allowed values are NoSelect, PreferNoSelect and NoSelectIfNew.",
            "enum": [
              "NoSelect",
              "PreferNoSelect",
              "NoSelectIfNew"
            ]
          },
          "key": {
            "type": "string",
            "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys.\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.",
            "validations": {
              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
            }
          },
          "operator": {
            "type": "string",
            "description": "Operator represents a key's relationship to the value.\nValid operators are Exists and Equal. Defaults to Equal.\nExists is equivalent to wildcard for value, so that a placement can\ntolerate all taints of a particular category.",
            "default": "Equal"
          },
          "tolerationSeconds": {
            "type": "integer",
            "description": "TolerationSeconds represents the period of time the toleration (which must be of effect\nNoSelect/PreferNoSelect, otherwise this field is ignored) tolerates the taint.\nThe default value is nil, which indicates it tolerates the taint forever.\nThe start time of counting the TolerationSeconds should be the TimeAdded in Taint, not the cluster\nscheduled time or TolerationSeconds added time."
          },
          "value": {
            "type": "string",
            "description": "Value is the taint value the toleration matches to.\nIf the operator is Exists, the value should be empty, otherwise just a regular string."
          }
        }
      }
    }
  },
  "status": {
    "description": "Status represents the current status of the Placement",
    "fields": {
      "conditions": {
        "type": "array",
        "description": "Conditions contains the different condition status for this Placement.",
        "fields": {
          "lastTransitionTime": {
            "type": "string",
            "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
            "required": true
          },
          "message": {
            "type": "string",
            "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            "required": true
          },
          "observedGeneration": {
            "type": "integer",
            "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            "validations": {
              "minimum": 0
            }
          },
          "reason": {
            "type": "string",
            "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            "required": true,
            "validations": {
              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
            }
          },
          "status": {
            "type": "string",
            "description": "status of the condition, one of True, False, Unknown.",
            "required": true,
            "enum": [
              "True",
              "False",
              "Unknown"
            ]
          },
          "type": {
            "type": "string",
            "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
            "required": true,
            "validations": {
              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
            }
          }
        }
      },
      "decisionGroups": {
        "type": "array",
        "description": "List of decision groups determined by the placement and DecisionStrategy.",
        "fields": {
          "clusterCount": {
            "type": "integer",
            "description": "Total number of clusters in the decision group. Clusters count is equal or less than the clusterPerDecisionGroups defined in the decision strategy.",
            "default": 0
          },
          "decisionGroupIndex": {
            "type": "integer",
            "description": "Present the decision group index. If there is no decision strategy defined all placement decisions will be in group index 0"
          },
          "decisionGroupName": {
            "type": "string",
            "description": "Decision group name that is defined in the DecisionStrategy's DecisionGroup."
          },
          "decisions": {
            "type": "array",
            "description": "List of placement decisions names associated with the decision group"
          }
        }
      },
      "numberOfSelectedClusters": {
        "type": "integer",
        "description": "NumberOfSelectedClusters represents the number of selected ManagedClusters"
      }
    }
  },
  "exampleYAML": "apiVersion: cluster.open-cluster-management.io/v1beta1\nkind: Placement\nmetadata:\n  name: example-placement\n  namespace: default\nspec:\n  clusterSets: []\n  decisionStrategy: {}\n  numberOfClusters: 1\n  predicates: []\n  prioritizerPolicy: {}\n"
}