{
  "kind": "ClusterInstance",
  "apiVersion": "siteconfig.open-cluster-management.io/v1alpha1",
  "metadata": {
    "group": "siteconfig.open-cluster-management.io",
    "version": "v1alpha1",
    "plural": "clusterinstances",
    "singular": "clusterinstance",
    "scope": "Namespaced"
  },
  "spec": {
    "description": "ClusterInstanceSpec defines the desired state of ClusterInstance",
    "fields": {
      "additionalNTPSources": {
        "type": "array",
        "description": "AdditionalNTPSources is a list of NTP sources (hostname or IP) to be added to all cluster\nhosts. They are added to any NTP sources that were configured through other means."
      },
      "apiVIPs": {
        "type": "array",
        "description": "APIVIPs are the virtual IPs used to reach the OpenShift cluster's API.\nEnter one IP address for single-stack clusters, or up to two for dual-stack clusters (at\nmost one IP address per IP stack used). The order of stacks should be the same as order\nof subnets in Cluster Networks, Service Networks, and Machine Networks."
      },
      "baseDomain": {
        "type": "string",
        "description": "BaseDomain is the base domain to use for the deployed cluster.",
        "required": true
      },
      "caBundleRef": {
        "type": "object",
        "description": "CABundle is a reference to a config map containing the new bundle of trusted certificates for the host.",
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "clusterImageSetNameRef": {
        "type": "string",
        "description": "ClusterImageSetNameRef is the name of the ClusterImageSet resource indicating which\nOpenShift version to deploy.",
        "required": true
      },
      "clusterName": {
        "type": "string",
        "description": "ClusterName is the name of the cluster.",
        "required": true
      },
      "clusterNetwork": {
        "type": "array",
        "description": "ClusterNetwork is the list of IP address pools for pods.",
        "fields": {
          "cidr": {
            "type": "string",
            "description": "CIDR is the IP block address pool.",
            "required": true
          },
          "hostPrefix": {
            "type": "integer",
            "description": "HostPrefix is the prefix size to allocate to each node from the CIDR.\nFor example, 24 would allocate 2^8=256 adresses to each node. If this\nfield is not used by the plugin, it can be left unset."
          }
        }
      },
      "clusterType": {
        "type": "string",
        "description": "ClusterType is a string representing the cluster type",
        "enum": [
          "SNO",
          "HighlyAvailable",
          "HostedControlPlane"
        ]
      },
      "cpuArchitecture": {
        "type": "string",
        "description": "CPUArchitecture is the default software architecture used for nodes that do not have an architecture defined.",
        "enum": [
          "x86_64",
          "aarch64",
          "multi"
        ],
        "default": "x86_64"
      },
      "cpuPartitioningMode": {
        "type": "string",
        "description": "CPUPartitioning determines if a cluster should be setup for CPU workload partitioning at install time.\nWhen this field is set the cluster will be flagged for CPU Partitioning allowing users to segregate workloads to\nspecific CPU Sets. This does not make any decisions on workloads it only configures the nodes to allow CPU\nPartitioning.\nThe \"AllNodes\" value will setup all nodes for CPU Partitioning, the default is \"None\".",
        "enum": [
          "None",
          "AllNodes"
        ],
        "default": "None"
      },
      "diskEncryption": {
        "type": "object",
        "description": "DiskEncryption is the configuration to enable/disable disk encryption for cluster nodes.",
        "fields": {
          "tang": {
            "type": "array",
            "description": "No description provided.",
            "fields": {
              "thumbprint": {
                "type": "string",
                "description": "No description provided."
              },
              "url": {
                "type": "string",
                "description": "No description provided."
              }
            }
          },
          "type": {
            "type": "string",
            "description": "No description provided.",
            "default": "none"
          }
        }
      },
      "extraAnnotations": {
        "type": "object",
        "description": "Additional cluster-wide annotations to be applied to the rendered templates"
      },
      "extraLabels": {
        "type": "object",
        "description": "Additional cluster-wide labels to be applied to the rendered templates"
      },
      "extraManifestsRefs": {
        "type": "array",
        "description": "ExtraManifestsRefs is list of config map references containing additional manifests to be applied to the cluster.",
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "holdInstallation": {
        "type": "boolean",
        "description": "HoldInstallation will prevent installation from happening when true.\nInspection and validation will proceed as usual, but once the RequirementsMet condition is true,\ninstallation will not begin until this field is set to false.",
        "default": false
      },
      "ignitionConfigOverride": {
        "type": "string",
        "description": "Json formatted string containing the user overrides for the initial ignition config"
      },
      "ingressVIPs": {
        "type": "array",
        "description": "IngressVIPs are the virtual IPs used for cluster ingress traffic.\nEnter one IP address for single-stack clusters, or up to two for dual-stack clusters (at\nmost one IP address per IP stack used). The order of stacks should be the same as order\nof subnets in Cluster Networks, Service Networks, and Machine Networks."
      },
      "installConfigOverrides": {
        "type": "string",
        "description": "InstallConfigOverrides is a Json formatted string that provides a generic way of passing\ninstall-config parameters."
      },
      "machineNetwork": {
        "type": "array",
        "description": "MachineNetwork is the list of IP address pools for machines.",
        "fields": {
          "cidr": {
            "type": "string",
            "description": "CIDR is the IP block address pool for machines within the cluster.",
            "required": true
          }
        }
      },
      "networkType": {
        "type": "string",
        "description": "NetworkType is the Container Network Interface (CNI) plug-in to install\nThe default value is OpenShiftSDN for IPv4, and OVNKubernetes for IPv6 or SNO",
        "enum": [
          "OpenShiftSDN",
          "OVNKubernetes"
        ],
        "default": "OVNKubernetes"
      },
      "nodes": {
        "type": "array",
        "description": "List of node objects",
        "required": true,
        "fields": {
          "automatedCleaningMode": {
            "type": "string",
            "description": "When set to disabled, automated cleaning will be avoided during provisioning and deprovisioning.\nSet the value to metadata to enable the removal of the disk\u2019s partitioning table only, without fully wiping\nthe disk. The default value is disabled.",
            "enum": [
              "metadata",
              "disabled"
            ],
            "default": "disabled"
          },
          "bmcAddress": {
            "type": "string",
            "description": "BmcAddress holds the URL for accessing the controller on the network.",
            "required": true
          },
          "bmcCredentialsName": {
            "type": "object",
            "description": "BmcCredentialsName is the name of the secret containing the BMC credentials (requires keys \"username\"\nand \"password\").",
            "required": true,
            "fields": {
              "name": {
                "type": "string",
                "description": "No description provided.",
                "required": true
              }
            }
          },
          "bootMACAddress": {
            "type": "string",
            "description": "Which MAC address will PXE boot? This is optional for some\ntypes, but required for libvirt VMs driven by vbmc.",
            "required": true,
            "validations": {
              "pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"
            }
          },
          "bootMode": {
            "type": "string",
            "description": "Provide guidance about how to choose the device for the image being provisioned.",
            "enum": [
              "UEFI",
              "UEFISecureBoot",
              "legacy"
            ],
            "default": "UEFI"
          },
          "cpuArchitecture": {
            "type": "string",
            "description": "CPUArchitecture is the software architecture of the node.\nIf it is not defined here then it is inheirited from the ClusterInstanceSpec.",
            "enum": [
              "x86_64",
              "aarch64"
            ]
          },
          "extraAnnotations": {
            "type": "object",
            "description": "Additional node-level annotations to be applied to the rendered templates"
          },
          "extraLabels": {
            "type": "object",
            "description": "Additional node-level labels to be applied to the rendered templates"
          },
          "hostName": {
            "type": "string",
            "description": "Hostname is the desired hostname for the host",
            "required": true
          },
          "hostRef": {
            "type": "object",
            "description": "HostRef is used to specify a reference to a BareMetalHost resource.",
            "fields": {
              "name": {
                "type": "string",
                "description": "Name specifies the name of the referenced object.",
                "required": true
              },
              "namespace": {
                "type": "string",
                "description": "Namespace specifies the namespace of the referenced object.",
                "required": true
              }
            }
          },
          "ignitionConfigOverride": {
            "type": "string",
            "description": "Json formatted string containing the user overrides for the host's ignition config\nIgnitionConfigOverride enables the assignment of partitions for persistent storage.\nAdjust disk ID and size to the specific hardware."
          },
          "installerArgs": {
            "type": "string",
            "description": "Json formatted string containing the user overrides for the host's coreos installer args"
          },
          "ironicInspect": {
            "type": "string",
            "description": "IronicInspect is used to specify if automatic introspection carried out during registration of BMH is enabled or\ndisabled",
            "enum": [
              "",
              "disabled"
            ],
            "default": ""
          },
          "nodeLabels": {
            "type": "object",
            "description": "NodeLabels allows the specification of custom roles for your nodes in your managed clusters.\nThese are additional roles that are not used by any OpenShift Container Platform components, only by the user.\nWhen you add a custom role, it can be associated with a custom machine config pool that references a specific\nconfiguration for that role.\nAdding custom labels or roles during installation makes the deployment process more effective and prevents the\nneed for additional reboots after the installation is complete."
          },
          "nodeNetwork": {
            "type": "object",
            "description": "NodeNetwork is a set of configurations pertaining to the network settings for the node.",
            "fields": {
              "config": {
                "type": "object",
                "description": "yaml that can be processed by nmstate, using custom marshaling/unmarshaling that will allow to populate nmstate config as plain yaml."
              },
              "interfaces": {
                "type": "array",
                "description": "Interfaces is an array of interface objects containing the name and MAC\naddress for interfaces that are referenced in the raw nmstate config YAML.\nInterfaces listed here will be automatically renamed in the nmstate config\nYAML to match the real device name that is observed to have the\ncorresponding MAC address. At least one interface must be listed so that it\ncan be used to identify the correct host, which is done by matching any MAC\naddress in this list to any MAC address observed on the host.",
                "fields": {
                  "macAddress": {
                    "type": "string",
                    "description": "mac address present on the host.",
                    "required": true,
                    "validations": {
                      "pattern": "^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$"
                    }
                  },
                  "name": {
                    "type": "string",
                    "description": "nic name used in the yaml, which relates 1:1 to the mac address.\nName in REST API: logicalNICName",
                    "required": true
                  }
                }
              }
            }
          },
          "pruneManifests": {
            "type": "array",
            "description": "PruneManifests represents a list of Kubernetes resource references that indicates which \"node-level\" manifests\nshould be pruned (removed).",
            "fields": {
              "apiVersion": {
                "type": "string",
                "description": "APIVersion is the version of the Kubernetes API to use when interacting\nwith the resource. It includes both the API group and the version, such\nas \"v1\" for core resources or \"apps/v1\" for deployments.",
                "required": true
              },
              "kind": {
                "type": "string",
                "description": "Kind is the type of Kubernetes resource being referenced.",
                "required": true
              }
            }
          },
          "role": {
            "type": "string",
            "description": "No description provided.",
            "enum": [
              "master",
              "worker"
            ],
            "default": "master"
          },
          "rootDeviceHints": {
            "type": "object",
            "description": "RootDeviceHints specifies the device for deployment.\nIdentifiers that are stable across reboots are recommended, for example, wwn: <disk_wwn> or\ndeviceName: /dev/disk/by-path/<device_path>",
            "fields": {
              "deviceName": {
                "type": "string",
                "description": "A Linux device name like \"/dev/vda\", or a by-path link to it like\n\"/dev/disk/by-path/pci-0000:01:00.0-scsi-0:2:0:0\". The hint must match\nthe actual value exactly."
              },
              "hctl": {
                "type": "string",
                "description": "A SCSI bus address like 0:0:0:0. The hint must match the actual\nvalue exactly."
              },
              "minSizeGigabytes": {
                "type": "integer",
                "description": "The minimum size of the device in Gigabytes.",
                "validations": {
                  "minimum": 0
                }
              },
              "model": {
                "type": "string",
                "description": "A vendor-specific device identifier. The hint can be a\nsubstring of the actual value."
              },
              "rotational": {
                "type": "boolean",
                "description": "True if the device should use spinning media, false otherwise."
              },
              "serialNumber": {
                "type": "string",
                "description": "Device serial number. The hint must match the actual value\nexactly."
              },
              "vendor": {
                "type": "string",
                "description": "The name of the vendor or manufacturer of the device. The hint\ncan be a substring of the actual value."
              },
              "wwn": {
                "type": "string",
                "description": "Unique storage identifier. The hint must match the actual value\nexactly."
              },
              "wwnVendorExtension": {
                "type": "string",
                "description": "Unique vendor storage identifier. The hint must match the\nactual value exactly."
              },
              "wwnWithExtension": {
                "type": "string",
                "description": "Unique storage identifier with the vendor extension\nappended. The hint must match the actual value exactly."
              }
            }
          },
          "suppressedManifests": {
            "type": "array",
            "description": "SuppressedManifests is a list of node-level manifest names to be excluded from the template rendering process"
          },
          "templateRefs": {
            "type": "array",
            "description": "TemplateRefs is a list of references to node-level templates. A node-level template consists of a ConfigMap\nin which the keys of the data field represent the kind of the installation manifest(s).\nNode-level templates are instantiated once for each node in the ClusterInstance CR.",
            "required": true,
            "fields": {
              "name": {
                "type": "string",
                "description": "Name specifies the name of the referenced object.",
                "required": true
              },
              "namespace": {
                "type": "string",
                "description": "Namespace specifies the namespace of the referenced object.",
                "required": true
              }
            }
          }
        }
      },
      "platformType": {
        "type": "string",
        "description": "PlatformType is the name for the specific platform upon which to perform the installation.",
        "enum": [
          "",
          "BareMetal",
          "None",
          "VSphere",
          "Nutanix",
          "External"
        ]
      },
      "proxy": {
        "type": "object",
        "description": "Proxy defines the proxy settings used for the install config",
        "fields": {
          "httpProxy": {
            "type": "string",
            "description": "HTTPProxy is the URL of the proxy for HTTP requests."
          },
          "httpsProxy": {
            "type": "string",
            "description": "HTTPSProxy is the URL of the proxy for HTTPS requests."
          },
          "noProxy": {
            "type": "string",
            "description": "NoProxy is a comma-separated list of domains and CIDRs for which the proxy should not be\nused."
          }
        }
      },
      "pruneManifests": {
        "type": "array",
        "description": "PruneManifests represents a list of Kubernetes resource references that indicates which manifests should be\npruned (removed).",
        "fields": {
          "apiVersion": {
            "type": "string",
            "description": "APIVersion is the version of the Kubernetes API to use when interacting\nwith the resource. It includes both the API group and the version, such\nas \"v1\" for core resources or \"apps/v1\" for deployments.",
            "required": true
          },
          "kind": {
            "type": "string",
            "description": "Kind is the type of Kubernetes resource being referenced.",
            "required": true
          }
        }
      },
      "pullSecretRef": {
        "type": "object",
        "description": "PullSecretRef is the reference to the secret to use when pulling images.",
        "required": true,
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "reinstall": {
        "type": "object",
        "description": "Reinstall specifications",
        "fields": {
          "generation": {
            "type": "string",
            "description": "Generation specifies the desired generation for the reinstallation operation.\nUpdating this field triggers a new reinstall request.",
            "required": true
          },
          "preservationMode": {
            "type": "string",
            "description": "PreservationMode defines the strategy for data preservation during reinstallation.\nSupported values:\n- None: No data will be preserved.\n- All: All Secrets and ConfigMaps in the ClusterInstance namespace labeled with the PreservationLabelKey will be\n  preserved.\n- ClusterIdentity: Only Secrets and ConfigMaps in the ClusterInstance namespace labeled with both the\n  PreservationLabelKey and the ClusterIdentityLabelValue will be preserved.\nThis field ensures critical cluster identity data is preserved when required.",
            "required": true,
            "enum": [
              "None",
              "All",
              "ClusterIdentity"
            ],
            "default": "None"
          }
        }
      },
      "serviceNetwork": {
        "type": "array",
        "description": "ServiceNetwork is the list of IP address pools for services.",
        "fields": {
          "cidr": {
            "type": "string",
            "description": "CIDR is the IP block address pool for machines within the cluster.",
            "required": true
          }
        }
      },
      "sshPublicKey": {
        "type": "string",
        "description": "SSHPublicKey is the public Secure Shell (SSH) key to provide access to instances.\nThis key will be added to the host to allow ssh access"
      },
      "suppressedManifests": {
        "type": "array",
        "description": "SuppressedManifests is a list of manifest names to be excluded from the template rendering process"
      },
      "templateRefs": {
        "type": "array",
        "description": "TemplateRefs is a list of references to cluster-level templates. A cluster-level template consists of a ConfigMap\nin which the keys of the data field represent the kind of the installation manifest(s).\nCluster-level templates are instantiated once per cluster (ClusterInstance CR).",
        "required": true,
        "fields": {
          "name": {
            "type": "string",
            "description": "Name specifies the name of the referenced object.",
            "required": true
          },
          "namespace": {
            "type": "string",
            "description": "Namespace specifies the namespace of the referenced object.",
            "required": true
          }
        }
      }
    }
  },
  "status": {
    "description": "ClusterInstanceStatus defines the observed state of ClusterInstance",
    "fields": {
      "clusterDeploymentRef": {
        "type": "object",
        "description": "Reference to the associated ClusterDeployment resource.",
        "fields": {
          "name": {
            "type": "string",
            "description": "Name of the referent.\nThis field is effectively required, but due to backwards compatibility is\nallowed to be empty. Instances of this type with an empty value here are\nalmost certainly wrong.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "default": ""
          }
        }
      },
      "conditions": {
        "type": "array",
        "description": "List of conditions pertaining to actions performed on the ClusterInstance resource.",
        "fields": {
          "lastTransitionTime": {
            "type": "string",
            "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
            "required": true
          },
          "message": {
            "type": "string",
            "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
            "required": true
          },
          "observedGeneration": {
            "type": "integer",
            "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
            "validations": {
              "minimum": 0
            }
          },
          "reason": {
            "type": "string",
            "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
            "required": true,
            "validations": {
              "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
            }
          },
          "status": {
            "type": "string",
            "description": "status of the condition, one of True, False, Unknown.",
            "required": true,
            "enum": [
              "True",
              "False",
              "Unknown"
            ]
          },
          "type": {
            "type": "string",
            "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
            "required": true,
            "validations": {
              "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
            }
          }
        }
      },
      "deploymentConditions": {
        "type": "array",
        "description": "List of hive status conditions associated with the ClusterDeployment resource.",
        "fields": {
          "lastProbeTime": {
            "type": "string",
            "description": "LastProbeTime is the last time we probed the condition."
          },
          "lastTransitionTime": {
            "type": "string",
            "description": "LastTransitionTime is the last time the condition transitioned from one status to another."
          },
          "message": {
            "type": "string",
            "description": "Message is a human-readable message indicating details about last transition."
          },
          "reason": {
            "type": "string",
            "description": "Reason is a unique, one-word, CamelCase reason for the condition's last transition."
          },
          "status": {
            "type": "string",
            "description": "Status is the status of the condition.",
            "required": true
          },
          "type": {
            "type": "string",
            "description": "Type is the type of the condition.",
            "required": true
          }
        }
      },
      "manifestsRendered": {
        "type": "array",
        "description": "List of manifests that have been rendered along with their status.",
        "fields": {
          "apiGroup": {
            "type": "string",
            "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.",
            "required": true
          },
          "kind": {
            "type": "string",
            "description": "Kind is the type of resource being referenced",
            "required": true
          },
          "lastAppliedTime": {
            "type": "string",
            "description": "lastAppliedTime is the last time the manifest was applied.\nThis should be when the underlying manifest changed.  If that is not known, then using the time when the API\nfield changed is acceptable.",
            "required": true
          },
          "message": {
            "type": "string",
            "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string."
          },
          "name": {
            "type": "string",
            "description": "Name is the name of the resource being referenced",
            "required": true
          },
          "namespace": {
            "type": "string",
            "description": "Namespace is the namespace of the resource being referenced"
          },
          "status": {
            "type": "string",
            "description": "Status is the status of the manifest",
            "required": true
          },
          "syncWave": {
            "type": "integer",
            "description": "SyncWave is the order in which the resource should be processed: created in ascending order, deleted in\ndescending order.",
            "required": true
          }
        }
      },
      "observedGeneration": {
        "type": "integer",
        "description": "Track the observed generation to avoid unnecessary reconciles"
      },
      "paused": {
        "type": "object",
        "description": "Paused provides information about the pause annotation set by the controller\nto temporarily pause reconciliation of the ClusterInstance.",
        "fields": {
          "reason": {
            "type": "string",
            "description": "Reason provides an explanation for why the paused annotation was applied.\nThis field may not be empty.",
            "required": true
          },
          "timeSet": {
            "type": "string",
            "description": "TimeSet indicates when the paused annotation was applied.",
            "required": true
          }
        }
      },
      "reinstall": {
        "type": "object",
        "description": "Reinstall status information.",
        "fields": {
          "conditions": {
            "type": "array",
            "description": "List of conditions pertaining to reinstall requests.",
            "fields": {
              "lastTransitionTime": {
                "type": "string",
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "required": true
              },
              "message": {
                "type": "string",
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "required": true
              },
              "observedGeneration": {
                "type": "integer",
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "validations": {
                  "minimum": 0
                }
              },
              "reason": {
                "type": "string",
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "required": true,
                "validations": {
                  "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                }
              },
              "status": {
                "type": "string",
                "description": "status of the condition, one of True, False, Unknown.",
                "required": true,
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "type": "string",
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                "required": true,
                "validations": {
                  "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                }
              }
            }
          },
          "history": {
            "type": "array",
            "description": "History maintains a record of all previous reinstallation attempts.\nEach entry captures details such as the generation, timestamp, and the differences in the ClusterInstance\nspecification that triggered the reinstall.\nThis field is useful for debugging, auditing, and tracking reinstallation events over time.",
            "fields": {
              "clusterInstanceSpecDiff": {
                "type": "string",
                "description": "ClusterInstanceSpecDiff provides a JSON representation of the differences between the\nClusterInstance spec at the time of reinstallation and the previous spec.\nThis field helps in tracking changes that triggered the reinstallation.",
                "required": true
              },
              "generation": {
                "type": "string",
                "description": "Generation specifies the generation of the ClusterInstance at the time of the reinstallation.\nThis value corresponds to the ReinstallSpec.Generation field associated with the reinstallation request.",
                "required": true
              },
              "requestEndTime": {
                "type": "string",
                "description": "RequestEndTime indicates the time at which SiteConfig completed processing the reinstall request.",
                "required": true
              },
              "requestStartTime": {
                "type": "string",
                "description": "RequestStartTime indicates the time at which SiteConfig was requested to reinstall.",
                "required": true
              }
            }
          },
          "inProgressGeneration": {
            "type": "string",
            "description": "InProgressGeneration is the generation of the ClusterInstance that is being processed for reinstallation.\nIt corresponds to the Generation field in ReinstallSpec and indicates the latest reinstall request that\nthe controller is acting upon."
          },
          "observedGeneration": {
            "type": "string",
            "description": "ObservedGeneration is the generation of the ClusterInstance that has been processed for reinstallation.\nIt corresponds to the Generation field in ReinstallSpec and indicates the latest reinstall request that\nthe controller has acted upon."
          },
          "requestEndTime": {
            "type": "string",
            "description": "RequestEndTime indicates the time at which SiteConfig completed processing the reinstall request."
          },
          "requestStartTime": {
            "type": "string",
            "description": "RequestStartTime indicates the time at which SiteConfig was requested to reinstall."
          }
        }
      }
    }
  },
  "exampleYAML": "apiVersion: siteconfig.open-cluster-management.io/v1alpha1\nkind: ClusterInstance\nmetadata:\n  name: example-clusterinstance\n  namespace: default\nspec:\n  baseDomain: \"example-baseDomain\"\n  clusterImageSetNameRef: \"example-clusterImageSetNameRef\"\n  clusterName: \"example-clusterName\"\n  nodes: []\n  pullSecretRef: {}\n  templateRefs: []\n"
}